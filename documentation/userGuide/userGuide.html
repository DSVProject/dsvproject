<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>TCD: Data Structure Visualisation Tool</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.css" rel="stylesheet">
    <link href="css/docs.css" rel="stylesheet">
    <link href="css/prettify.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="assets/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body data-spy="scroll" data-target=".bs-docs-sidebar">
    <header class="jumbotron" id="overview">
      <div class="container">
        <h1>Getting started</h1>
        <p class="lead">Overview of the framework, its contents, and how to get started with it.</p>
    </header>
    <div class="container">
      <!-- Docs nav
      ================================================== -->
      <div class="row">
        <div class="span3 bs-docs-sidebar">
          <ul class="nav nav-list bs-docs-sidenav">
            <li><a href="#the-framework"><i class="icon-chevron-right"></i> The Framework</a></li>
            
            <li><a href="#the-basic-items"><i class="icon-chevron-right"></i> The Basic Items</a></li>
            <li><a href="#square-object"><i class="icon-chevron-right"></i> &nbsp;&nbsp; Square Object</a></li>
            <li><a href="#circle-object"><i class="icon-chevron-right"></i> &nbsp;&nbsp; Circle Object</a></li>
            <li><a href="#edge-object"><i class="icon-chevron-right"></i> &nbsp;&nbsp; Edge Object</a></li>
            <li><a href="#user-object"><i class="icon-chevron-right"></i> &nbsp;&nbsp; User Object</a></li>
            <li><a href="#core-object"><i class="icon-chevron-right"></i> &nbsp;&nbsp; Managing All This: Core Object</a></li>
            <li><a href="#constant-js"><i class="icon-chevron-right"></i> &nbsp;&nbsp; An Important File: Constant.js</a></li>
            
            <li><a href="#new-visualisation"><i class="icon-chevron-right"></i> Creating a New Visualisation</a></li>
            <li><a href="#two-files"><i class="icon-chevron-right"></i> &nbsp;&nbsp; The Two Files</a></li>
            <li><a href="#custom-items"><i class="icon-chevron-right"></i> &nbsp;&nbsp; Custom Items</a></li>
            
            <li><a href="#learning-mode"><i class="icon-chevron-right"></i> Learning Mode</a></li>
            <li><a href="#valid-target"><i class="icon-chevron-right"></i> &nbsp;&nbsp; User Shape and Valid Targets</a></li>
            <li><a href="#place-holder"><i class="icon-chevron-right"></i> &nbsp;&nbsp; Place Holders</a></li>
          </ul>
        </div>
        <div class="span9">

          <!-- The Framework
          ================================================== -->
          <section id="the-framework">
            <div class="page-header">
              <h1>1. The Framework</h1>
            </div>
            <p>This framework serves as a base to implement <strong>Data Structure Visualisations</strong>, providing tools to create graphic items, animate and manage them. It was built in a way that anyone with some knowledge of <strong>Object Oriented Programming</strong> and <strong>JavaScript</strong> can use it, without having knowledge about <strong>SVG</strong> or <strong>D3</strong>.</p>
            <p>In this user guide we'll begin by studying each class and then we will proceed to learn how to use them to create a visualisation.</p>
            <p>The classes provided were designed to control the graphic part of the visualisation, and should be integrated with the algorithms of each data structure.</p>
            
            <h2>1.1. File Structure</h2>
            <p>You've cloned the project to your computer and now what? Let's understand how the framework directories are organised:</p>
<pre class="prettyprint">
DSVProject/
├── code/
│   ├── bootstrap/
│   ├── d3/
│   ├── js/
│   │   ├── util.js
│   │   ├── algorithms/
│   │   │   ├── template.js
│   │   │   ├── visualisation JS files
│   │   ├── framework/
│   │   │   ├── coreObject.js
│   │   │   ├── squareObject.js
│   │   │   ├── circleObject.js
│   │   │   ├── edgeObject.js
│   │   │   ├── userObject.js
│   │   │   ├── svg.js
│   │   │   ├── constant.js
│   │   ├── custom/
│   │   │   ├── Custom shapes and sets of shapes JS files
│   │   ├── Other JS files
│   ├── bootstrap/
│   ├── css/
│   │   ├── animation.css
│   │   ├── template.css
│   │   ├── Other CSS files
│   ├── index.html
│   ├── template.html
│   ├── Visualisatons HTML files
├── documentation/
│   ├── userGuide/
│   │   ├── css/
│   │   ├── js/
│   │   ├── img/
│   │   ├── userGuide.html
│   ├── .doc files
└── readme
</pre>
            <p>Although it might look complex there are only 3 folders that you should worry about:</p>
            
            <ul>
              <li><strong>code/</strong> : where you'll place your visualisation .html file.</li>
              <li><strong>algorithms/</strong> : where you'll place your visualisation .js file.</li>
              <li><strong>custom/</strong> : where you'll place your custom shape or set of shapes, in case you decided to create one.</li>
            </ul>
            
            <p>The .css file that controls the styling of the shapes if called <strong>animation.css</strong>.</p>
            <p>The main website and the visualisation pages were built using <a href="http://getbootstrap.com">Boostrap</a>. The .css file that control the styling of the pages is called <strong>template.css</strong>, and the javascript functions related to the page behaviour are located inside <strong>util.js</strong>.</p>
            
          </section>
          
          <!-- The Basic Items
          ================================================== -->
          <section id="the-basic-items">
            <div class="page-header">
              <h1>2. The Basic Items</h1>
            </div>
            <p>All visualisations will be built using instances of these items. For example, an array will be a combination of Squares positioned side by side, while a node will be a combination of a Square with an Edge. For this reason let's take a look on each of them to understand how they're meant to be used.</p>
          </section>
          
          <!-- SquareObject -->
          <section id="square-object">
            <h2>2.1. Square Object</h2>
            <p>The square is one of the basic shapes and here's how it will look on the screen:</p>
            <img src="img/squareObject.png" alt="">
            <p>As you noticed by the annotations on the image this object is composed of 3 elements: a shape, an inner text and a label (the last two being optional) but we'll get into this a little ahead.</p>
            
            <h3>2.1.1. Constructor and Parameters</h3>
            <p>The class is called SquareObject, and to create an instance of a class in javascript all you have to do is the same that you would do in any other OO language:</p>
<pre class="prettyprint linenums">
var newObj = new SquareObject(coreObj, id, x, y, text, label, shapeClass, textClass, labelClass);
</pre>
            <p>Now let's understand all those parameters:</p>
            <ul>
              <li><strong>coreObj:</strong> this parameter is the reference to the instance of CoreObject; as you will see later on, CoreObject is responsible to keep track of all existing objects. With this reference, this object will be able to interact with the others if needed (for example in the Learning Mode).</li>
              <li><strong>id:</strong> an unique identifier for this instance.</li>
              <li><strong>x:</strong> the x coordinate of this object inside the svg container.</li>
              <li><strong>y:</strong> the y coordinate of this object inside the svg container.</li>
              <li><strong>text:</strong> the inner text of this object (b. on the image above).</li>
              <li><strong>label:</strong> the label of this object (c. on the image above).</li>
              <li><strong>shapeClass:</strong> the CSS class of the shape SVG element.</li>
              <li><strong>textClass:</strong> the CSS class of the text SVG element.</li>
              <li><strong>labelClass:</strong> the CSS class of the text SVG element.</li>
            </ul>
            <p>As you will be able to notice in the javadoc, some of this parameters are not obligatory (like text, label, classes), making it easy to customise a shape. Regarding the classes, it is always recommended to send "null" as parameter since all instances will inherit a default class, unless you would like it to have a different look.</p>
            <p>Now let's take a look of a few examples:</p>
            <img src="img/squareExample.png" alt="">
            <p>Square 01 is an instance of a SquareObject without a label, while Square 02 have one. All the other Squares have an EdgeObject associated with them, where each instance was created with a different "outgoingPoint" parameter, which means that when the pointer is null (in here indicated by the color red) it will point into a different direction. When leaving from the bottom, if the SquareObject has a label, the Edge will take this into consideration (as seen in Square 08).</p>
            
            <h3>2.1.2. Fields</h3>
            <p>These fields will store all the important data regarding this instance.</p>
            
            <h4>2.1.2.1. Core</h4>
<pre class="prettyprint linenums">
this.coreObj = coreObj;
</pre>
            <p>Store the reference to coreObj parameter.</p>
            
            <h4>2.1.2.2. Offset Values</h4>
<pre class="prettyprint linenums">
this.textAdjustX = defaultProperties.shape.width / 2;
this.textAdjustY = defaultProperties.shape.height / 1.75;
this.labelAdjustY = defaultProperties.shape.height + 30;
</pre>
            <p>When drawing the properties onto the screen, the inner text and the label may need some positioning adjustments, which will be stored in these.</p>
            
            <h4>2.1.2.3. Property Map</h4>
<pre class="prettyprint linenums">
this.propObj = {
  "id": id,

  "shape": {
    "class": shapeClass,
    "x": x,
    "y": y,
    "width": defaultProperties.shape.width,
    "height": defaultProperties.shape.height,
    "fill": defaultProperties.shape.fill.default,
    "fillOpacity": defaultProperties.shape["fill-opacity"].default,
    "stroke": defaultProperties.shape.stroke.default,
    "strokeWidth": defaultProperties.shape["stroke-width"].default
  },

  "text": {
    "class": textClass,
    "x": x + this.textAdjustX,
    "y": y + this.textAdjustY,
    "fill": defaultProperties.text.stroke.default,
    "fontFamily": defaultProperties.text["font-family"],
    "fontWeight": defaultProperties.text["font-weight"],
    "fontSize": defaultProperties.text["font-size"],
    "textAnchor": defaultProperties.text["text-anchor"],
    "text": text
  },

  "label": {
    "class": labelClass,
    "x": x + this.textAdjustX,
    "y": y + this.labelAdjustY,
    "text": label
  },

  "toRemove": false,

  "isValidTarget": false
}
</pre>
            <p>This is the most important field of this object. It is a property map that will store all the data regarding the shape, the text, the label and other variables used for functionality. When drawing this object on the screen these values will be taken into consideration.</p>
            <p>But as you might have noticed there's two properties in there that doesn't seem quite like "graphical", and you're right. "toRemove" is a Boolean flag that will signalise if this object shall be deleted when the next drawing occur while "isValidTarget" is used for the Learning Mode. You'll see more about this later on.</p>
            
            <h4>2.1.2.4. Edges</h4>
<pre class="prettyprint linenums">
this.edgeList = [];
</pre>
            <p>This is an array that will contain all the instances of EdgeObject that are binded to this object.</p>
            
            <h3>2.1.3. Methods</h3>
            <p>Let's first take a look at all the methods from this class:</p>
<pre class="prettyprint linenums">
this.getAttributes = function () {...}
this.getEdges = function () {...}
this.getID = function () {...}
this.setShapeClass = function (newClass) {...}
this.getShapeClass = function () {...}
this.moveShape = function (x, y) {...}
this.getCoordinateX = function () {...}
this.getEdgeCoordinateX = function (point) {...}
this.getCoordinateY = function () {...}
this.getEdgeCoordinateY = function (point) {...}
this.setWidth = function (newWidth) {...}
this.getWidth = function () {...}
this.setHeight = function (newHeight) {...}
this.getHeight = function () {...}
this.setFill = function (newFill) {...}
this.setFillOpacity = function (newOpacity) {...}
this.setStroke = function (newStroke) {...}
this.setStrokeWidth = function (newStrokeWidth) {...}
this.setText = function (newText) {...}
this.getText = function () {...}
this.setTextClass = function (newClass) {...}
this.getTextClass = function () {...}
this.setFontColor = function (newColor) {...}
this.setLabel = function (newLabel) {...}
this.setLabelClass = function (newClass) {...}
this.getLabelClass = function () {...}
this.setToRemove = function (bool) {...}
this.getToRemove = function () {...}
this.setIsValidTarget = function (bool) {...}
this.getIsValidTarget = function () {...}
this.addEdge = function (edgeObj) {...}
this.draw = function (duration) {...}
this.remove = function (duration) {...}
this.cloneObject = function () {...}
this.cloneProperties = function (prop) {...}
this.cloneEdges = function (edges) {...}
this.createPlaceHolder = function (allowSwap) {...}
</pre>
            <p>Most of them are just getters and setters for the property map and when creating your own visualisation they are the only ones you should worry. The other methods are used internally by the framework, so heres a brief explanation on them:</p>
            
            <h4>2.1.3.1. Add Edge</h4>
            <p>This method will add an instance of EdgeObject to this object edgeList[]. Edges are always stored in the origin object, even if the edge is bidirectional.</p>
            
            <h4>2.1.3.2. Draw and Remove</h4>
            <p>The Draw method will get the data from the property map and bind it to HTML elements created with D3, making them appear on the screen or update the looks of an existing object.</p>
            <p>The Remove method will delete the HTML elements, removing the object from the screen.</p>
            
            <h4>2.1.3.3. GetEdgeCoordinate</h4>
            <p>An EdgeObject is the representation of the Line SVG element, which goes from point (x1,y1) to point (x2,y2). When getting these coordinates this function will be called, returning them while taking into consideration the properties of this object.</p>
            
            <h4>2.1.3.4. Cloning</h4>
            <p>Cloning objects is very important in the way this framework was designed and this will become clearer after we study the CoreObject. There is one main function that calls two subfunctions: </p>
<pre class="prettyprint linenums">
this.cloneObject = function () {
  var clone = new SquareObject(this.coreObj);
  clone.cloneProperties(this.propObj);
  clone.cloneEdges(this.edgeList);

  return clone;
}
</pre>
            <p>Which calls:</p>
<pre class="prettyprint linenums">
this.cloneProperties = function (prop) {
  this.propObj = clone(prop);
}

this.cloneEdges = function (edges) {
  var newList = [];
  var clone;

  for (var key in edges) {
    clone = new EdgeObject(this.coreObj);
    clone.cloneProperties(edges[key].getAttributes());

    newList[key] = clone;
  }

  this.edgeList = newList;
}
</pre>
            <p>These functions create an exact clone of the current instance, without memory references, what will enable the animation to happen step by step.</p>
            <p>When creating a clone, you have to create a new instance of the current object (SquareObject in this case) and the only parameter required is coreObj. The subfunctions will take care of copying the property map and the edge array.</p>
            
            <h4>2.1.3.5. Place holders (Learning Mode)</h4>
            <p>This method is only important when creating a visualisation with Learning Mode enabled. If this object is classified as a valid target for the Learning Mode interaction a place holder will be created with behavourial functions to be called responding to user actions, making changes to this and other object properties.</p>    
          </section>
          
          <!-- CircleObject -->
          <section id="circle-object">
            <h2>2.2. Circle Object</h2>
            <p>The circle is one of the basic shapes and here's how it will look on the screen:</p>
            <img src="img/circleObject.png" alt="">
            <p>As you noticed by the annotations on the image this object is composed of 3 elements: a shape, an inner text and a label (the last two being optional) but we'll get into this a little ahead.</p>
            
            <h3>2.2.1. Constructor and Parameters</h3>
            <p>The class is called CircleObject, and to create an instance of a class in javascript all you have to do is the same that you would do in any other OO language:</p>
<pre class="prettyprint linenums">
var newObj = new CircleObject(coreObj, id, cx, cy, radius, text, label, shapeClass, textClass, labelClass);
</pre>
            <p>Now let's understand all those parameters:</p>
            <ul>
              <li><strong>coreObj:</strong> this parameter is the reference to the instance of CoreObject; as you will see later on, CoreObject is responsible to keep track of all existing objects. With this reference, this object will be able to interact with the others if needed (for example in the Learning Mode).</li>
              <li><strong>id:</strong> an unique identifier for this instance.</li>
              <li><strong>cx:</strong> the cx coordinate of this object inside the svg container.</li>
              <li><strong>cy:</strong> the cy coordinate of this object inside the svg container.</li>
              <li><strong>radius:</strong> the radius of this object.</li>
              <li><strong>text:</strong> the inner text of this object (b. on the image above).</li>
              <li><strong>label:</strong> the label of this object (c. on the image above).</li>
              <li><strong>shapeClass:</strong> the CSS class of the shape SVG element.</li>
              <li><strong>textClass:</strong> the CSS class of the text SVG element.</li>
              <li><strong>labelClass:</strong> the CSS class of the text SVG element.</li>
            </ul>
            <p>As you will be able to notice in the javadoc, some of this parameters are not obligatory (like text, label, classes), making it easy to customise a shape. Regarding the classes, it is always recommended to send "null" as parameter since all instances will inherit a default class, unless you would like it to have a different look.</p>
            <p>Now let's take a look of a few examples:</p>
            <img src="img/circleExample.png" alt="">
            <p>Circle 01 is an instance of a CircleObject without a label, while Circle 02 have one. All the other Circles have an EdgeObject associated with them, where each instance was created with a different "outgoingPoint" parameter, which means that when the pointer is null (in here indicated by the color red) it will point into a different direction. When leaving from the bottom, if the CircleObject has a label, the Edge will take this into consideration (as seen in Circle 08).</p>
            
            <h3>2.2.2. Fields</h3>
            <p>These fields will store all the important data regarding this instance.</p>
            
            <h4>2.2.2.1. Core</h4>
<pre class="prettyprint linenums">
this.coreObj = coreObj;
</pre>
            <p>Store the reference to coreObj parameter.</p>
            
            <h4>2.2.2.2. Offset Values</h4>
<pre class="prettyprint linenums">
this.textAdjust = defaultProperties.text["font-size"]/3;
this.labelAdjust = defaultProperties.shape.radius + 30;
</pre>
            <p>When drawing the properties onto the screen, the inner text and the label may need some positioning adjustments, which will be stored in these.</p>
            
            <h4>2.2.2.3. Property Map</h4>
<pre class="prettyprint linenums">
this.propObj = {
  "id": id,

  "shape": {
    "class": shapeClass,
    "cx": cx,
    "cy": cy,
    "r": radius,
    "fill": defaultProperties.shape.fill.default,
    "fillOpacity": defaultProperties.shape["fill-opacity"].default,
    "stroke": defaultProperties.shape.stroke.default,
    "strokeWidth": defaultProperties.shape["stroke-width"].default
  },

  "text": {
    "class": textClass,
    "x": cx,
    "y": cy + this.textAdjust,
    "fill": defaultProperties.text.stroke.default,
    "fontFamily": defaultProperties.text["font-family"],
    "fontWeight": defaultProperties.text["font-weight"],
    "fontSize": defaultProperties.text["font-size"],
    "textAnchor": defaultProperties.text["text-anchor"],
    "text": text
  },

  "label": {
    "class": labelClass,
    "x": cx,
    "y": cy + this.labelAdjust,
    "text": label
  },

  "toRemove": false,

  "isValidTarget": false
}
</pre>
            <p>This is the most important field of this object. It is a property map that will store all the data regarding the shape, the text, the label and other variables used for functionality. When drawing this object on the screen these values will be taken into consideration.</p>
            <p>But as you might have noticed there's two properties in there that doesn't seem quite like "graphical", and you're right. "toRemove" is a Boolean flag that will signalise if this object shall be deleted when the next drawing occur while "isValidTarget" is used for the Learning Mode. You'll see more about this later on.</p>
            
            <h4>2.2.2.4. Edges</h4>
<pre class="prettyprint linenums">
this.edgeList = [];
</pre>
            <p>This is an array that will contain all the instances of EdgeObject that are binded to this object.</p>
            
            <h3>2.2.3. Methods</h3>
            <p>Let's first take a look at all the methods from this class:</p>
<pre class="prettyprint linenums">
this.getAttributes = function () {...}
this.getEdges = function () {...}
this.getID = function () {...}
this.setShapeClass = function (newClass) {...}
this.getShapeClass = function () {...}
this.moveShape = function (x, y) {...}
this.getCoordinateCX = function () {...}
this.getEdgeCoordinateX = function (point) {...}
this.getCoordinateCY = function () {...}
this.getEdgeCoordinateY = function (point) {...}
this.setRadius = function (newRadius) {...}
this.getRadius = function () {...}
this.setFill = function (newFill) {...}
this.setFillOpacity = function (newOpacity) {...}
this.setStroke = function (newStroke) {...}
this.setStrokeWidth = function (newStrokeWidth) {...}
this.setText = function (newText) {...}
this.getText = function () {...}
this.setTextClass = function (newClass) {...}
this.getTextClass = function () {...}
this.setFontColor = function (newColor) {...}
this.setLabel = function (newLabel) {...}
this.setLabelClass = function (newClass) {...}
this.getLabelClass = function () {...}
this.setToRemove = function (bool) {...}
this.getToRemove = function () {...}
this.setIsValidTarget = function (bool) {...}
this.getIsValidTarget = function () {...}
this.addEdge = function (edgeObj) {...}
this.draw = function (duration) {...}
this.remove = function (duration) {...}
this.cloneObject = function () {...}
this.cloneProperties = function (prop) {...}
this.cloneEdges = function (edges) {...}
this.createPlaceHolder = function (allowSwap) {...}
</pre>
            <p>Most of them are just getters and setters for the property map and when creating your own visualisation they are the only ones you should worry. The other methods are used internally by the framework, so heres a brief explanation on them:</p>
            
            <h4>2.2.3.1. Add Edge</h4>
            <p>This method will add an instance of EdgeObject to this object edgeList[]. Edges are always stored in the origin object, even if the edge is bidirectional.</p>
            
            <h4>2.2.3.2. Draw and Remove</h4>
            <p>The Draw method will get the data from the property map and bind it to HTML elements created with D3, making them appear on the screen or update the looks of an existing object.</p>
            <p>The Remove method will delete the HTML elements, removing the object from the screen.</p>
            
            <h4>2.2.3.3. GetEdgeCoordinate</h4>
            <p>An EdgeObject is the representation of the Line SVG element, which goes from point (x1,y1) to point (x2,y2). When getting these coordinates this function will be called, returning them while taking into consideration the properties of this object.</p>
            
            <h4>2.2.3.4. Cloning</h4>
            <p>Cloning objects is very important in the way this framework was designed and this will become clearer after we study the CoreObject. There is one main function that calls two subfunctions: </p>
<pre class="prettyprint linenums">
this.cloneObject = function () {
  var clone = new CircleObject(this.coreObj);
  clone.cloneProperties(this.propObj);
  clone.cloneEdges(this.edgeList);

  return clone;
}
</pre>
            <p>Which calls:</p>
<pre class="prettyprint linenums">
this.cloneProperties = function (prop) {
  this.propObj = clone(prop);
}

this.cloneEdges = function (edges) {
  var newList = [];
  var clone;

  for (var key in edges) {
    clone = new EdgeObject(this.coreObj);
    clone.cloneProperties(edges[key].getAttributes());

    newList[key] = clone;
  }

  this.edgeList = newList;
}
</pre>
            <p>These functions create an exact clone of the current instance, without memory references, what will enable the animation to happen step by step.</p>
            <p>When creating a clone, you have to create a new instance of the current object (SquareObject in this case) and the only parameter required is coreObj. The subfunctions will take care of copying the property map and the edge array.</p>
            
            <h4>2.2.3.5. Place holders (Learning Mode)</h4>
            <p>This method is only important when creating a visualisation with Learning Mode enabled. If this object is classified as a valid target for the Learning Mode interaction a place holder will be created with behavourial functions to be called responding to user actions, making changes to this and other object properties.</p>    
          </section>
          
          <!-- EdgeObject -->
          <section id="edge-object">
            <h2>2.3. Edge Object</h2>
            
            <p>The edge (in SVG knows as line) is one of the basic elements, used to connect two shapes. It might also have a marker element, in case the edge needs to be directed.</p>
            <img src="img/edgeExample.png" alt="">
            <p>There are three types of edges:</p>
            <ul>
              <li><strong>Undirected (a):</strong> connect the two shapes, without any specified direction.</li>
              <li><strong>Unidirectional (b):</strong> connect the two shapes, in this case from 02 to 03.</li>
              <li><strong>Bidirectional (c):</strong> connect the two shapes, in both directions.</li>
            </ul>
            <p>Although and EdgeObject is connecting two shapes it only belongs to the <strong>edgeList[]</strong> as we've mentioned earlier. This happens for two reasons: it makes the management of edges easier for the developer and during the drawing operations it will avoid redundancy.</p>
            
            <h3>2.3.1. Constructor and Parameters</h3>
            <p>The class is called EdgeObject, and to create an instance of a class in javascript all you have to do is the same that you would do in any other OO language:</p>
<pre class="prettyprint linenums">
var newObj = new EdgeObject(coreObj, id, idObjectA, idObjectB, edgeClass, edgeType, outboundPoint, inboundPoint, typeObjCreated);
</pre>
            <p>Now let's understand all those parameters:</p>
            <ul>
              <li><strong>coreObj:</strong> this parameter is the reference to the instance of CoreObject; as you will see later on, CoreObject is responsible to keep track of all existing objects. With this reference, this object will be able to interact with the others if needed (for example in the Learning Mode).</li>
              <li><strong>id:</strong> an unique identifier for this instance.</li>
              <li><strong>idObjectA:</strong> the id of the origin object.</li>
              <li><strong>idObjectB:</strong> the id of the destination object. If null a small edge will be created following the orientation of the origin point (as seen in the square and circle examples).</li>
              <li><strong>edgeClass:</strong> the CSS class of the line svg element.</li>
              <li><strong>edgeType:</strong> indicates wether the edge is unidirectional (from A -> B), bidirectional or has no direction.</li>
              <li><strong>outboundPoint:</strong> indicates from which position of the shape the edge will originate.</li>
              <li><strong>inboundPoint:</strong> indicates at which position of the shape the edge will arrive.</li>
              <li><strong>typeObjCreated:</strong> when the edge is a valid target for the learning mode, this property indicates which type of object will be created at the end of this edge.</li>
            </ul>
            <p>As you will be able to notice in the javadoc, some of this parameters are not obligatory (like idObjectB, class), making it easy to customise an edge. Regarding the class, it is always recommended to send "null" as parameter since all instances will inherit a default class, unless you would like it to have a different look.</p>
            
            <h3>2.3.2. Fields</h3>
            <p>These fields will store all the important data regarding this instance.</p>
            
            <h4>2.3.2.1. Core</h4>
<pre class="prettyprint linenums">
this.coreObj = coreObj;
</pre>
            <p>Store the reference to coreObj parameter.</p>
            
            <h4>2.3.2.3. Property Map</h4>
<pre class="prettyprint linenums">
this.propObj = {
  "id": id,

  "idObjectA": idObjectA,

  "idObjectB": idObjectB,

  "type": edgeType,

  "outboundPoint": outboundPoint != null ? outboundPoint : EDGE_POSITION.CENTER,

  "inboundPoint": inboundPoint != null ? inboundPoint : EDGE_POSITION.CENTER,

  "markerStart": idObjectB != null ? defaultProperties.marker.start.default : defaultProperties.marker.start.null,

  "markerEnd": idObjectB != null ? defaultProperties.marker.end.default : defaultProperties.marker.end.null,

  "edge": {
    "class": edgeClass,
    "x1": null,
    "y1": null,
    "x2": null,
    "y2": null,
    "stroke": idObjectB != null ? defaultProperties.edge.stroke.default : defaultProperties.edge.stroke.null,
    "strokeWidth": idObjectB != null ? defaultProperties.edge["stroke-width"].default : defaultProperties.edge["stroke-width"].null
  },
    
  "isValidTarget": false,

  "typeObjCreated": typeObjCreated
}
</pre>
            <p>This is the most important field of this object. It is a property map that will store all the data regarding the edge and other variables used for functionality. When drawing this object on the screen these values will be taken into consideration.</p>
            
            <h3>2.3.3. Methods</h3>
            <p>Let's first take a look at all the methods from this class:</p>
<pre class="prettyprint linenums">
this.getAttributes = function () {...}
this.getID = function () {...}
this.getIdObjectA = function () {...}
this.setIdObjectA = function (newID) {...}
this.getIdObjectB = function () {...}
this.setIdObjectB = function (newID) {...}
this.getType = function () {...}
this.setType = function (newType) {...}
this.setOutboundPoint = function (newValue) {...}
this.getOutboundPoint = function () {...}
this.setInboundPoint = function (newValue) {...}
this.getInboundPoint = function () {...}
this.setMarkerStart = function (newMarker) {...}
this.setMarkerEnd = function (newMarker) {...}
this.setEdgeClass = function (newClass) {...}
this.getCoordinateX1 = function(){...}
this.getCoordinateY1 = function(){...}
this.getCoordinateX2 = function(){...}
this.getCoordinateY2 = function(){...}
this.setStroke = function (newStroke) {...}
this.setStrokeWidth = function (newStrokeWidth) {...}
this.setIsValidTarget = function (bool) {...}
this.getIsValidTarget = function () {...}
this.calculatePath = function () {...}
this.draw = function (duration) {...}
this.remove = function (duration) {...}
this.cloneProperties = function (prop) {...}
this.createPlaceHolder = function () {...}
</pre>
            <p>Most of them are just getters and setters for the property map and when creating your own visualisation they are the only ones you should worry. The other methods are used internally by the framework, so heres a brief explanation on them:</p>
            
            <h4>2.3.3.1. setIdObjectA</h4>
            <p>As we've mentioned earlier the instance of this object is added to ObjectA's edgeList[], so when changing this object (in a tree rotation for example) a special function will be called, that will take care of removing the edge from the old object edgeList[] and adding it to the new one.</p>
            
            <h4>2.3.3.2. Draw and Remove</h4>
            <p>The Draw method will get the data from the property map and bind it to HTML elements created with D3, making them appear on the screen or update the looks of an existing object.</p>
            <p>The Remove method will delete the HTML elements, removing the object from the screen.</p>
            
            <h4>2.2.3.3. calculatePath</h4>
            <p>An EdgeObject is the representation of the Line SVG element, which goes from point (x1,y1) to point (x2,y2). This points are determined by the two objects which this edge is connecting. When this class is instantiated, or any of the two objects is changed, this function will be called getting the coordinates needed.</p>
            
            <h4>2.2.3.4. Cloning</h4>
            <p>Cloning objects is very important in the way this framework was designed and this will become clearer after we study the CoreObject. Here is the cloning function for this object: </p>
<pre class="prettyprint linenums">
this.cloneProperties = function (prop) {
  this.propObj = clone(prop);
  this.calculatePath();
}
</pre>
            <p>Shapes that possesses edges will call this function when cloning their edges. This will return a deep copy of this object properties, without the memory references.</p>
            
            <h4>2.2.3.5. Place holders (Learning Mode)</h4>
            <p>This method is only important when creating a visualisation with Learning Mode enabled. If this object is classified as a valid target for the Learning Mode interaction a place holder will be created with behavourial functions to be called responding to user actions, making changes to this and other object properties.</p>   
            
          </section>
          
          <!-- UserObject -->
          <section id="user-object">
            <h2>2.4. User Object</h2>
          </section>
          
          <!-- CoreObject -->
          <section id="core-object">
            <h2>2.5. Managing all this: Core Object</h2>
            <p><strong>CoreObject.js</strong> is the most important file of this framework. It works as an interface between all the other classes and your javascript file containing the data structure's algorithm. In this sections we will study all Core methods and understand when their use.</p>
            
            <h3>2.5.1. Constructor</h3>
            <p>This class shall be instantiated in any algorithm javascipt file without any parameters, like this:</p>
<pre class="prettyprint linenums">
var coreObj = new CoreObject();
</pre>
            <p>With this instance you'll make use of this class to realise all other graphical changes.</p>
            
            <h3>2.5.2. Fields</h3>
            <p>All fields, except for objectList are for private use. Let's understand each of them:</p>
            <ul>
              <li>
<pre class="prettyprint">
this.objectList = [];
</pre>
                <p>This array will store instances of all existing objects.</p>
              </li>
              <li>
<pre class="prettyprint">
this.stateList = [];
</pre>
                <p>This array will store all states used to create a step-by-step animation.</p>
              </li>
              <li>
<pre class="prettyprint">
this.stateCount = 0;
this.stateAnimation = 0;
</pre>
                <p><strong>stateCount</strong> stores how many states exists while <strong>stateAnimation</strong> store which step is currently on the screen.</p>
              </li>
              <li>
<pre class="prettyprint">
this.actionArray = [];
this.actionCount = 0;
</pre>
                <p><strong>actionArray</strong> is used to store "checkpoints" of each action executed by the user. This enables methods like <strong>undo</strong> and <strong>redo</strong>. <strong>actionCount</strong> tells us how many actions are stored.</p>
              </li>
              <li>
<pre class="prettyprint">
this.animationStatus = ANIMATION_STATUS.STOP;
</pre>
                <p>This variable is used to control the playing status of the animation.</p>
              </li>
              <li>
<pre class="prettyprint">
this.variableWatchList = [];
this.logList = [];
</pre>
                <p>Those two arrays are used to manage the content of the <strong>log panel</strong> and the <strong>variable watch panel</strong>.</p>
              </li>
            </ul>
            
            <h3>2.5.3. Validation Methods</h3>
            <p>Summary:</p>
<pre class="prettyprint linenums">
this.isLearningMode = function () {...}
this.newActionEnabled = function () {...}
this.displayAlert = function (message) {...}
</pre>
            <h4>2.5.3.1. isLearningMode</h4>
            <p>This function will return wether the Learning Mode is active or not. In a visualisation where the Learning Mode is implemented, this function shall be called in your algorithm javascript file, when calling the methods and then run the correspondent set of code according to what this function returned.</p>
<pre class="prettyprint linenums">
if (coreObj.isLearningMode()){
  // create learning mode objects
} else {
  // run default method
}
</pre>
    
            <h4>2.5.3.2. newActionEnabled</h4>
            <p>When using the Learning Mode, the user should complete or cancel the current action before making any further changes. This function shall be called when trying to run any method; it return false if any UserObject exists, and the code should be interrupted, preventing more actions from happening.</p>
<pre class="prettyprint linenums">
this.push = function (item) {
  if (top.value >= cap || item.trim() == "") {
    return false;
  }

  if (coreObj.newActionEnabled() == false) return false;

  ...
}
</pre>
            
            <h4>2.5.3.3. displayAlert</h4>
            <p>If some condition was not satisfied and you want to alert the user you should call this function, sending the message as parameter.</p>
<pre class="prettyprint linenums">
coreObj.displayAlert("Please finish or cancel the current action before making any further changes.");
</pre>
            <p>Which will result in (displayed at the top of the screen):</p>
            <img src="img/alert.png" alt ="">
            
            <h3>2.5.4. Animation Methods</h3>
            <h4>2.5.4.1. State Methods</h4>
            <p>To have a step-by-step animation of the algorithms we make use of "states". Just like in state machines, we save the current state of each existing object in a given time, creating a series of snapshots so we can iterate through them later.</p>
            <p>When a visualisation page is called the state list should be initialised, like this:</p>
<pre class="prettyprint linenums">
var StackArray = function(){
  var self = this;
  var coreObj = new CoreObject();
  
  coreObj.newStateList();

  ...
}
</pre>
            <p>This will initialise all variables used for controling the states.</p>
            
            <p>Then it's time to begin saving states, but first let's understand what composes a state:</p>
<pre class="prettyprint">
var state = {
  data : null,
  log : null,
  variables : null,
  pseudocodeLine : null
};
</pre>
            <ul>
              <li><strong>data</strong> will store the copy of all existing objects with their current state.</li>
              <li><strong>log</strong> will store a copy of the log messages displayed in this state.</li>
              <li><strong>variables</strong> will store a copy of the variable values in this state.</li>
              <li><strong>pseudocodeLine</strong> will store which pseudocode line should be highlighted in this state.</li>
            </ul>
            <p>Now let's see how the states should be saved in order to make an animation. To do this we'll use the <strong>enqueue</strong> method, from a Queue Array Implementation:</p>
<pre class="prettyprint linenums">
this.enqueue = function (item) {
  if (tail.value >= cap || item.trim() == "") {
    coreObj.displayAlert("The input should not be empty.");
    return false;
  }

  this.generatePseudocode(ENQUEUE);

  mArray[tail.value].setText(item);
  coreObj.saveState("Inserting the new value", 0);

  tail.value++;
  tail.drawing.setFill(defaultProperties["shape"]["fill"]["update"]);
  coreObj.saveState();

  tail.edge.setIdObjectB(mArray[tail.value].getID());

  tail.drawing.setText(tail.value);
  tail.drawing.setFill(defaultProperties["shape"]["fill"]["default"]);
  coreObj.saveVariableToWatch("head", head.value);
  coreObj.saveVariableToWatch("tail", tail.value);
  coreObj.saveState("Update the tail pointer.", 1);

  coreObj.begin();
}
</pre>
            <p>To save a state only two things are required, both being optional: a <strong>message</strong> that will be printed on the log panel, and which <strong>pseudocode line</strong> that will be highlighted. <strong>Variables</strong> should be saved separately (as seen in lines 20 and 21), this allows the programmer to save as many variables as he want.</p>
            
            <h4>2.5.4.2. Control Methods</h4>
            <p>After you've saved all desired states is time to play with them. In order to do this there's only one function that you have to call:</p>
<pre class="prettyprint">
coreObj.begin();
</pre>
            <p>This function will begin playing the states related to the last action performed.</p>
            
            <p>Functions such as <strong>play</strong>, <strong>pause</strong>, <strong>next</strong>, <strong>previous</strong> are called straight from the HTML file, to iterate through the steps of the animation, and they all will call <strong>draw</strong>, sending the a state to be displayed on the screen.</p>
            <p>All this functions take into consideration the user speed preference, which is accessible with the <strong>getAnimationDuration</strong> function.</p>
            
            <h4>2.5.4.3. Panel Methods</h4>
            <p>Here's the list of all the core functions that interact with the panels:</p>
<pre class="prettyprint linenums">
this.clearLog = function () {...}
this.saveLogMessageToList = function (message) {...}
this.printLog = function (logObj) {...}
this.clearVariableWatch = function(){...}
this.saveVariableToWatch = function (variableName, variableValue) {...}
this.printVariableWatch = function (variablesObj) {...}
this.clearPseudocode = function () {...}
this.addPseudocodeLine = function (id, instruction) {...}
this.highlightPseudocode = function (lineNumber) {...}
</pre>
            <p>But when creating your own visualisation you'll only have to call 3 of them:</p>
            <ul>
              <li><strong>saveVariableToWatch</strong>: to save the current state of a variable, to be displayed in the Variable Watch Panel.</li>
              <li><strong>clearPseudocode</strong>: before running a method, to display the right set of instructions.</li>
              <li><strong>addPseudocodeLine</strong>: when creating sets of pseudocode.</li>
            </ul>
            <p>All other methods are called internaly in the core, so you don't have to worry.</p>
            
            <h3>2.5.5. Object Constructor Methods</h3>
            <p>All basic items that we've studied before must be created or deleted using the active instance of CoreObject, which will return the just created instance reference to the algorithm javascript file. This will make it possible for the core to manage and organise all existing objects, making the framework more consistent. With the reference that is returned you will be able to interact with each instance, applying any desired graphic changes.</p>
            <p>Here's how these functions look like:</p>
<pre class="prettyprint linenums">
/**
    * Create a square graphic element.
    *
    * @param {!(String|Number)} id : the id of this object.
    * @param {!Number} x : the x coordinate of this object inside the svg element.
    * @param {!Number} y : the y coordinate of this object inside the svg element.
    * @param {?String=} text : the inner text of this object, that will be displayed on the screen.
    * @param {?String=} label : the text underneath this object, that will be displayed on the screen.
    * @param {?String=} shapeClass : the CSS class of the shape svg element.
    * @param {?String=} textClass : the CSS class of the text svg element (inside the shape).
    * @param {?String=} labelClass : the CSS class of the text svg element (underneath the shape).
    *
    * @return {SquareObject} : the new object.
    */
this.newSquareObject = function (id, x, y, text, label, shapeClass, textClass, labelClass) {
  this.objectList[id] = new SquareObject(this, id, x, y, text, label, shapeClass, textClass, labelClass);

  return this.objectList[id];
}

/**
  * Create a circle graphic element.
  *
  * @param {!(String|Number)} id : the id of this object.
  * @param {!Number} cx : the cx coordinate of this object inside the svg element.
  * @param {!Number} cy : the cy coordinate of this object inside the svg element.
  * @param {!Number} radius : the radius of this object.
  * @param {?String=} text : the inner text of this object, that will be displayed on the screen.
  * @param {?String=} label : the text underneath this object, that will be displayed on the screen.
  * @param {?String=} shapeClass : the CSS class of the rect svg element.
  * @param {?String=} textClass : the CSS class of the text svg element (inside the shape).
  * @param {?String=} labelClass : the CSS class of the text svg element (underneath the shape).
  *
  * @return {CircleObject} : the new object.
  */
this.newCircleObject = function (id, cx, cy, radius, text, label, shapeClass, textClass, labelClass) {
  this.objectList[id] = new CircleObject(this, id, cx, cy, radius, text, label, shapeClass, textClass, labelClass);

  return this.objectList[id];
}

/**
  * Create a user graphic element (used for the learning mode).
  *
  * @param {!(String|Number)} id : the id of this object.
  * @param {!Number} cx : the cx coordinate of this object inside the svg element.
  * @param {!Number} cy : the cy coordinate of this object inside the svg element.
  * @param {!Number} radius : the radius of this object.
  * @param {?String=} text : the inner text of this object, that will be displayed on the screen.
  * @param {?String=} shapeClass : the CSS class of the rect svg element.
  * @param {?String=} textClass : the CSS class of the text svg element (inside the shape).
  * @param {!Const} type : the type of this userObject (defined at 'animation/constant.js' : USER_OBJ_TYPE).
  * @param {!Bool=} allowSwap: if this instance is a VALUE type object, this parameter should be passed. If true, this object's text will be swapped during the interactions.
  * @param {!(String|Number)=} bindedObjID : if this instance is a MOVEMENT type object, it should be binded to another object.
  *
  * @return {userObject} : the new object.
  */
this.newUserObject = function (id, cx, cy, radius, text, shapeClass, textClass, type, allowSwap, bindedObjID) {
  this.objectList[id] = new UserObject(this, id, cx, cy, radius, text, shapeClass, textClass, type, allowSwap, bindedObjID);

  return this.objectList[id];
}

/**
  * Create an edge graphic element, that will be stored in the origin object edgelist[].
  *
  * @param {!(String|Number)} id : the id of this object.
  * @param {!String} idObjectA : the id of the origin object.
  * @param {?String=} idObjectB : the id of the destination object. If null a small edge will be created following the orientation of the origin point.
  * @param {?String=} edgeClass : the CSS class of the line svg element.
  * @param {!Const} edgeType : a constant value (defined at 'animation/constant.js' : EDGE_TYPE) indicating wether the vertex is unidirectional (from A -> B), bidirectional or has no direction.
  * @param {?Const=} outboundPoint : a constant value (defined at 'animation/constant.js' : EDGE_POSITION) indicating from which point of the shape the edge will originate. If null the CENTER position will be used.
  * @param {?Const=} inboundPoint : a constant value (defined at 'animation/constant.js' : EDGE_POSITION) indicating at which point of the shape the edge will arrive. If null the CENTER position will be used.
  * @param {?Const=} typeObjCreated : a constant value (defined at 'animation/constant.js' : USER_TYPE_OBJ_CREATED) indicating which object should be created to insert a new value in the learning mode.
  *
  * @return {EdgeObject} : the new object.
  */
this.newEdgeObject = function (id, idObjectA, idObjectB, edgeClass, edgeType, outboundPoint, inboundPoint, typeObjCreated) {
  var newEdge = new EdgeObject(this, id, idObjectA, idObjectB, edgeClass, edgeType, outboundPoint, inboundPoint, typeObjCreated);

  this.objectList[idObjectA].addEdge(newEdge);

  return newEdge;
}
</pre>
            <p>To better understand this let's look at an example:</p>
<pre class="prettyprint linenums">
this.push = function(item) {
  ...
  
  top = new Node();
  top.item = item;
  top.next = oldtop;
  top.drawing = coreObj.newSquareObject(++counterID, 150, 200, item, null, "node", null, null);
  top.edge = coreObj.newEdgeObject(counterID, top.drawing.getID(), null, null, EDGE_TYPE.UNIDIRECTIONAL, EDGE_POSITION.BOTTOM, EDGE_POSITION.TOP);

  coreObj.saveState("Inserting new node.", 0);

  ...
}
</pre>
            
            <p>For deletions we have those two functions:</p>
<pre class="prettyprint linenums">
/**
  * Set a flag for the object to be removed on the next draw action.
  *
  * @param {!(String|Number)} id : the id of the item to be removed.
  */
this.removeShape = function (id) {
  this.objectList[id].setToRemove(true);
}

/**
  * Set a flag for all objects of the selected class to be removed on the next draw action.
  *
  * @param {String} selectedClass : the class of the items to be removed.
  * @param {Number} duration : the duration of the animation.
  */
this.removeAll = function (selectedClass, duration) {
  for (var key in this.objectList) { 
    if (this.objectList[key].getShapeClass() == selectedClass) {

      this.objectList[key].setToRemove(true);
    }
  }
}
</pre>
            <p>The first one is used to delete a single item, while the second will delete all items that match the provided class (for example deleting all nodes when clearing a linked list visualisation).</p>
            
            <!--
            <h3>2.5.6. Object Interaction Methods</h3>
            <p>There are some methods that are called from the basic shapes to interact with other shapes, but mediated by the core. When creating a new visualisation you don't have to use any of these functions but let's take a look to understand what each of them do:</p>
            
            <h3>2.5.7. Other Methods</h3>
            <p>Summary:</p>
<pre class="prettyprint linenums">
this.createGroups = function () {...}
this.createMarkers = function () {...}
</pre>
            <p>These methods are called from constructor. They will create all necessary SVG groups and other elements, used to better organise the HTML DOM.</p>
          -->
          </section>
          
          <!-- Constant.js -->
          <section id="constant-js">
            <h2>2.6. An important file: Constant.js</h2>
            
            <p>To improve code abstraction all default values and constants are defined in one single file. This make doing changes to the code a lot easier as changing the values here will affect all the framework. Normally, a parameter responsible for the aspec of an item will receive a value defined in this file.</p>
            <p>Let's check some important items declared in this file:</p>
            <ul>
              <li><strong>Constant Enums</strong>: many constructors will receive a parameter 
                <p>Heres the list containing all of them:</p>
<pre class="prettyprint linenums">
/**
  * Values used by CoreAnimObject, to control the playing status of the animation.
  *
  * @const 
  */
const ANIMATION_STATUS = {
  PAUSE: 0,
  PLAY: 1,
  STOP: -1
};

/**
  * Values used when creating an instance of EdgeObject.
  *
  * @const 
  */
const EDGE_TYPE = {
  UNDIRECTED: 0,
  UNIDIRECTIONAL: 1,
  BIDIRECTIONAL: 2
};

/**
  * Values used when creating an instance of EdgeObject.
  *
  * @const 
  */
const EDGE_POSITION = {
  CENTER: 0,
  TOP: 1,
  LEFT: 2,
  BOTTOM: 3,
  RIGHT: 4
};

/**
  * Values used when creating an instance of UserObject.
  *
  * @const 
  */
const USER_OBJ_TYPE = {
  VALUE: 0,
  MOVEMENT: 1
};

/**
  * Values used when creating an instance of EdgeObject, for the learning mode to determine which object will be created.
  * The names stand for the type and how many edges.
  *
  * @const 
  */
const USER_TYPE_OBJ_CREATED = {
  CIRCLE_EDGE_0: 0,
  CIRCLE_EDGE_1: 1,
  CIRCLE_EDGE_2: 2,
  SQUARE_EDGE_0: 3,
  SQUARE_EDGE_1: 4,
};
</pre>
              </li>
              <li><strong>Default IDS, Classes and Properties</strong>: to improve code abstraction and keep the visual identity of the framework, many properties, classes and ids are defined here. 
                <p>Heres the list containing all of them:</p>
<pre class="prettyprint linenums">
/**
  * Default class names used across the framework, defined here to improve code abstraction.
  *
  * @const 
  */
const DEFAULT_CLASSES = {
  SHAPE:"shape",
  EDGE:"edge",
  TEXT:{
    INNER:"innerText",
    LABEL:"labelText"
  },
  MARKER:"marker",
  LEARNING_MODE:{
    SHAPE:"learning",
    ACTIVE:"active",
    PLACE_HOLDER:"placeHolder",
    OBJECT_SELECTED:"selected"
  },
  PAGE:{
    PSEUDOCODE:{
      HIGHLIGHT:"codeHighlight"
    }
  }
}

/**
  * Default IDs used across the framework, defined here to improve code abstraction.
  *
  * @const 
  */
const DEFAULT_IDS = {
  PAGE:{
    LOG:"log",
    VARIABLE:"variables",
    PSEUDOCODE:"pseudocode",
    LEARNING_MODE:"chk-learn",
    ANIMATION_DURATION:"animation-duration",
    ALERT_PLACEHOLDER:"alert_placeholder"
  },
  HTML_ELEMENT:{
    PSEUDOCODE_LINE:"line"
  },
  SVG_GROUP:{
    MAIN:"g-main",
    MARKER:"g-marker",
    SHAPE:"g-shape",
    TEXT:"g-text",
    LABEL:"g-label",
    EDGE:"g-edge"
  },
  SVG_ELEMENT:{
    SHAPE:"shape-",
    USER_SHAPE:"u-shape-",
    TEXT:"text-",
    USER_TEXT:"u-text-",
    LABEL:"label-",
    EDGE:"edge-",
    USER_NEW_OBJ:"protoObj"
  },
  SVG_MARKER:{
    START:{
      DEFAULT:"reverseArrowDefault",
      NULL:"reverseArrowNull"
    },
    END:{
      DEFAULT:"arrowDefault",
      NULL:"arrowNull"
    }
  }
}

/**
  * Default properties used across the framework, defined here to improve code abstraction.
  *
  * @const 
  */
const defaultProperties = {
  shape:{
    "radius":25,
    "width":50,
    "height":50,
    "stroke":{
      "default":"black",
      "draggable":"tomato"
    },
    "stroke-width":{
      "default":2,
      "draggable":2
    },
    "fill":{
      "default":"white",
      "draggable":"grey",
      "update":"lightskyblue",
      "delete":"tomato"
    },
    "fill-opacity":{
      "default":1.0,
      "draggable":0.2
    }
  },
  text:{
    "font-family":"sans-serif",
    "font-size":18,
    "text-anchor":"middle",
    "stroke":{
      "default":"black",
      "innerTextBlack":"black",
      "innerTextWhite":"ivory"
    }
  },
  edge:{
    "stroke":{
      "default":"black",
      "null":"tomato"
    },
    "stroke-width":{
      "default":3,
      "null":4
    }
  },
  marker:{
    "width":5,
    "height":3,
    "refX":{
      "start":-7,
      "end":7
    },
    "start":{
      "default": "url(#reverseArrowDefault)",
      "null": "url(#reverseArrowNull)"
    },
    "end":{
      "default": "url(#arrowDefault)",
      "null": "url(#arrowNull)"
    }
  }
}
</pre>
              </li>
            </ul>
          </section>
          
          <!-- Creating a New Visualisation
          ================================================== -->
          <section id="new-visualisation">
            <div class="page-header">
              <h1>3. Creating a New Visualisation</h1>
            </div>
            <p>Now that you know all the items of the framework it's time to create your own Data Structure Visualisation.</p>
            <img src="img/dataStructureVisualisation.png" alt="">
            
            <p>In this section you'll see what you have to do to achieve this. But before we begin we would like to recommend a developing tool: <a href="http://brackets.io/?lang=en">Brackets</a>.</p>
            <p>Brackets as described in its own website is an open source code editor for web designers and front-end developers. We've used it for the entire development of this tool and found it to be very productive. A few points that we would like to mention:</p>
            <ul>
              <li><strong>Frequent sprints:</strong> every four weeks or so a new version of the software is released, with new functionalities and improvements.</li>
              <li><strong>Code completion:</strong> not only for html tags, but your file tree. When inserting files this really come in handy.</li>
              <img src="img/bracketsCompletion.png" alt="">
              <li><strong>Nice organisation:</strong> once you select your working folder it will show your file tree in the sidebar, and a quick access to recently open files.</li>
              <img src="img/brackets.png" alt="">
              <li><strong>Quick edit:</strong> make changes to functions and styles without even leaving your current working file!</li>
              <div class="thumbnail">
                <img src="img/functionQuickEdit.png" alt="">
              </div>
              <p>See the contents of a function and make changes on the go.</p>
              <ul class="thumbnails">
                <li class="span3">
                  <div class="thumbnail">
                    <img src="img/imgPreview.png" alt="">
                  </div>
                  <p>Preview of images inside the code.</p>
                </li>
                <li class="span3">
                  <div class="thumbnail">
                    <img src="img/cssPreview.png" alt="">
                  </div>
                  <p>See the output style while coding.</p>
                </li>
              </ul>
              
              <li><strong>Live preview:</strong> brackets offers a live preview using Google Chrome, making it possible to see the changes as you code them.</li>
              <li><strong>Customisation:</strong> it has support to themes you can make it look the way you want, with different colors to syntax highlight in a way that you won't have to get used to a new pattern.</li>
              <li><strong>It is free.</strong></li>
            </ul>
          </section>
          
          <!-- The Two Files
          ================================================== -->
          <section id="two-files">
            <h2>3.1. The two files</h2>
            <p>In most cases you will only have to create two files: an <strong>HTML</strong> and a <strong>JavaScript</strong>. This will only be different if you decide to create a custom shape or set of shapes, which will take another <strong>JavaScript</strong> file.</p>
            
            <h3>3.1.1. HTML</h3>
            <p>To create the HTML file of your data structure visualisation the first thing you have to do is to copy the <strong>template.html</strong> provided and rename it to fit the data structure. In you'll find the following lines:</p>
<pre class="prettyprint">
&lt;!-- Template: Page Title --&gt; (line 7)
&lt;!-- Template: Visualisation Title --&gt; (line 37)
&lt;!-- Template: Method's buttons --&gt; (line 42)
  &lt;!-- Template: Text input button (methods that require an input value) --&gt; (line 44)
    &lt;!-- Template: Textbox id, for future reference --&gt; (line 52)
      &lt;!-- Template: onclick function --&gt; (line 55)
  &lt;!-- Template: Normal button (methods that don't require an input value) --&gt; (line 64)
  &lt;!-- Template: Learning Mode Buttons (If not available comment this div tag) --&gt; (line 69)
&lt;!-- Template: Your Visualisation Scripts --&gt; (line 217)
  // Template: Your js file instance and calls to methods. (line 221)
</pre>
            <p>Below each of them you'll find the code that needs to be adapted for the new page.</p>
            
            <h4>3.1.1.1. The Buttons</h4>
            <img src="img/buttons.png" alt="">
            <p>For the methods in our visualisations we only use two kinds of buttons: <strong>with (a)</strong> and <strong>without (b)</strong> text input.</p>
            <p>If a method requires an input, a text box (c) will appear, an the method will be executed after pressing the button. If no input is required the method will be executed immediatly.</p>
            <p>Below you'll find the html code for each type of button:</p>
            <ul>
            <li>With text input:</li>
<pre class="prettyprint linenums">
&lt;!-- Template: Text input button (methods that require an input value) -->
&lt;div class="btn-group">
  &lt;button type="button" class="btn btn-default navbar-btn dropdown-toggle" data-toggle="dropdown">
    Method Name &lt;span class="caret">&lt;/span>
  &lt;/button>
  &lt;ul class="dropdown-menu" role="menu">
    &lt;form class="navbar-form">
      &lt;div class="input-group">
        &lt;!-- Template: Textbox id, for future reference -->
        &lt;input id="txt-input" type="text" class="form-control" maxlength="4">
        &lt;span class="input-group-btn">
          &lt;!-- Template: onclick function -->
          &lt;button class="btn btn-default" type="button" onclick="">
            &lt;span class="glyphicon glyphicon-ok">&lt;/span>
          &lt;/button>
        &lt;/span>
      &lt;/div>
    &lt;/form>
  &lt;/ul>
&lt;/div>
</pre>
              <li>Without text input:</li>
<pre class="prettyprint linenums">
&lt;!-- Template: Normal button (methods that don't require an input value) -->
&lt;button type="button" class="btn btn-default navbar-btn" onclick="">Method Name&lt;/button>
</pre>
            </ul>

            <p>There is also the Learning Mode button group that in most cases will be commented, unless you're also going to develop a learning mode for the current visualisation.</p>
            <img src="img/learningModeButton.png" alt="">
            <p>Here is how its code looks like:</p>
<pre class="prettyprint linenums">
&lt;!-- Template: Learning Mode Buttons (If not available comment this div tag) -->
&lt;!--
&lt;div id="div-learning-buttons" class="btn-group popover-dismiss" data-popover="popover" data-html="true" data-placement="bottom" title="Learning Mode" data-content="Use this switch to toggle between the &lt;b>Exploration&lt;/b> and the &lt;b>Learning&lt;/b> modes.&lt;br/>&lt;br/>In Exploration mode animations will happen automatically.&lt;br/>In Learning mode you will have to create the final state of each method.">
  &lt;button id="chk-answer-btn" type="button" disabled class="btn btn-default navbar-btn" data-toggle="tooltip" data-placement="bottom" title="Check Answer" onclick="">
        &lt;span class="glyphicon glyphicon-check">&lt;/span>
  &lt;/button>
  &lt;button id="restart-btn" type="button" disabled class="btn btn-default navbar-btn" data-toggle="tooltip" data-placement="bottom" title="Restart" onclick="">
        &lt;span class="glyphicon glyphicon-repeat">&lt;/span>
  &lt;/button>
  &lt;button id="cancel-btn" type="button" disabled class="btn btn-default navbar-btn" data-toggle="tooltip" data-placement="bottom" title="Cancel" onclick="">
        &lt;span class="glyphicon glyphicon-remove">&lt;/span>
  &lt;/button>
  &lt;button type="button" id="chk-learn" class="btn btn-default navbar-btn" data-toggle="tooltip" data-placement="bottom" title="Toggle Mode">Learning Mode&lt;/button>
&lt;/div>
-->
</pre>
            <p>To make it visible just remove the comment tags (&lt;!-- -->).</p>
            
            <h4>3.1.1.2. The scrips</h4>
            <p>The last thing to be changed in the html file is the scripts. You will have to make reference to the new file and create calls to your methods. For this example we're going to use the StackArray.html file.</p>

<pre class="prettyprint linenums">
&lt;!-- Template: Your Visualisation Scripts -->
&lt;script src="js/algorithms/stackArray.js">&lt;/script>

&lt;script type="text/javascript">
  var stack = new StackArray();
  var core = stack.getCore();

  function push () {
    var input = $("#txt-input");

    stack.push(input.val());
    input.val("");
  }

  function pop () {
    stack.pop();
  }

  function empty () {
    stack.init();
  }

  // DEFAULT METHODS. DO NOT REMOVE.

  function previous () {
    core.previous();
  }

  function play () {
    core.play();
  }

  function pause () {
    core.pause();
  }

  function next () {
    core.next();
  }

  function undo () {
    core.undo();
  }

  function redo () {
    core.redo();
  }
&lt;/script>
</pre>
            <p>As you can see in the visualisation above we've referenced our algorithm file in line 2. Then we'll have to create a new instance of our class (line 5). An important method that every algorithm js file should have is this:</p>
            <img src="img/getCore.png" alt="">
            <p>This method is called in line 6, and will allow us to call the default media control methods (from line 23 until the end of the script).</p>
            <p>Other than that you should create calls for the methods in your class, sending inputs if required, making use of the ids defined on the creation of the html buttons (line 9).</p>
            
            <h3>3.1.2. JavaScript</h3>
            <p>To create the JS file of your data structure visualisation we recommend that you use the <strong>template.js </strong>file provided as it follows some guidelines of our framework. Here's how it looks like:</p>
            
<pre class="prettyprint linenums">
/**
  * Defines a Pointer object, that contains:
  *   {Number} value
  *   {Object} drawing : an instace of one of the basic shapes (squareObject, nodeObject, etc)
  *   {Object} edge : an instace of the edgeObject
  */
var Pointer = function () {
  var value;
  var drawing;
  var edge;
}

/**
  * Defines a Stack object (Array implementation). Used to keep track of the object internally and to interact with the animations.
  */
var Template = function(){
  var self = this;
  var coreObj = new CoreObject();
  
  // ARRAY TO STORE LEARNING MODE OBJECTS
  var learnObj = [];
  
  // CONSTANTS FOR PSEUDOCODE GENERATION
  const PUSH = 0,
        POP = 1;
  
  // CREATE INITIAL ITEMS IF ANY
  coreObj.newStateList();

  var cap = 16;
  var top = new Pointer();
  var mArray = [];
  
  for (var i=0; i&lt;16; i++){
    mArray[i] = coreObj.newSquareObject(i, (i+1)*50, 300, null, i, null, null, null);  
  }
  
  top.value = 0;
  top.drawing = coreObj.newSquareObject("top", 50, 50, 0, "top", null, null, null);

  top.edge = coreObj.newEdgeObject("top", top.drawing.getID(), mArray[top.value].getID(), null, EDGE_TYPE.UNIDIRECTIONAL, EDGE_POSITION.BOTTOM, EDGE_POSITION.TOP);
  
  coreObj.saveState();
  coreObj.begin(0);

  // DEFAULT METHODS
  this.getCore = function () {
    return coreObj;
  }
  
  this.generatePseudocode = function (command) {
    coreObj.clearPseudocode();
    
    switch (command) {
        case PUSH:
          coreObj.addPseudocodeLine(lineNo, "Instruction");
          break;
        case POP:
          coreObj.addPseudocodeLine(lineNo, "Instruction");
          break;
    }
  }
  
  // PARTICULAR METHODS
  
  this.init = function() {...}
  
  this.isEmpty = function () {...}
  
  this.push = function (item) {...}
  
  this.pop = function () {...}
}
</pre>
            <p>Now let's understand what's happening in there.</p>
            
            <h4>3.1.2.1. Organising the data and the graphics</h4>
            <p>As we've seen when studying CoreObject each graphic object created is returned to this class for you to manage. This will give you access to each instance, making it easier to do necessary graphic changes.</p>
            <p>Let's pick a few examples to have an idea of how to manage all this:</p>
            <ul>
              <li><strong>Array:</strong> in certain cases it will be possible to run the algorithms using only the graphic part, like in Array implementations.
<pre class="prettyprint linenums">
for (var i=0; i&lt;16; i++){
  mArray[i] = coreObj.newSquareObject(i, (i+1)*50, 300, null, i, null, null, null);  
}
</pre>
                <p>Since you have the instance of your graphic object, to access its properties all you have to do is:</p>
<pre class="prettyprint linenums">
mArray[top.value].getText();
      
mArray[top.value].setText(item);
</pre>
                <p>Just like in other OO languages, using "." will grant access to the class methods.</p>
              </li>
              <li><strong>Node:</strong> in most of the cases an auxiliar data structure will be required. To explain this we will be using a Tree Node as example.
                <p>Normally this is the content of a Node:</p>
<pre class="prettyprint linenums">
var Node = function () {
  var value;
  var key;
  var leftChild;
  var rightChild;
}
</pre>
                <p>In these variables we're going to store the data refering to this Node, and the instances of its children. But we also need to keep track of the visual structures, so let's see what will change:</p>
<pre class="prettyprint linenums">
var Node = function () {
  var value;
  var key;
  var leftChild;
  var rightChild;
  
  var drawing;
  var leftEdge;
  var rightEdge;
}
</pre>
                <p>We still have all the data variables, but now we also have variables to store instances of the graphic objects, that just like in the array example will enable us to make changes to the properties as we run our algorithms.</p>
                <p>To make it even more clearer, let's take a look at this snipt:</p>
<pre class="prettyprint linenums">
this.root = new Node();

root.value = newValue;
root.key = newKey;
root.leftChild = null;
root.rightChild = null;

root.drawing = coreObj.newCircleObject(newKey, this.getCX(), this.getCY(), defaultProperties.radius, newValue, null, null, null, null);
root.leftEdge = coreObj.newEdgeObject(newKey + "l", root.drawing.getID(), null, null, EDGE_TYPE.UNIDIRECTIONAL, EDGE_POSITION.CENTER, EDGE_POSITION.TOP);
root.rightEdge = coreObj.newEdgeObject(newKey + "r", root.drawing.getID(), null, null, EDGE_TYPE.UNIDIRECTIONAL, EDGE_POSITION.CENTER, EDGE_POSITION.TOP);
</pre>
                <p>In it we're creating a new Node and making it root of our tree. Now let's see what would happen if we would insert a new Node on the left subtree:</p>
<pre class="prettyprint linenums">
var newNode = new Node();

newNode.value = newValue;
newNode.key = newKey;
newNode.leftChild = null;
newNode.rightChild = null;

newNode.drawing = coreObj.newCircleObject(newKey, this.getCX(), this.getCY(), defaultProperties.radius, newValue, null, null, null, null);
newNode.leftEdge = coreObj.newEdgeObject(newKey + "l", root.drawing.getID(), null, null, EDGE_TYPE.UNIDIRECTIONAL, EDGE_POSITION.CENTER, EDGE_POSITION.TOP);
newNode.rightEdge = coreObj.newEdgeObject(newKey + "r", root.drawing.getID(), null, null, EDGE_TYPE.UNIDIRECTIONAL, EDGE_POSITION.CENTER, EDGE_POSITION.TOP);

this.root.leftChild = newNode;
this.root.leftEdge.setIdObjectB(newNode.drawing.getID());
</pre>
                <p>We create a new node just as we did before, then we update the data (line 12) and then the graphics (line 13).</p>
                
                <p>By doing this we can keep the data and the graphics apart from each other, but still easy to manage and access then. In the tree example, you would be able to use recurssion to iterate through the tree by having pointers to the children (leftChild and rightChild) and while doing that you can change the edge properties to let the user know what's happening, by having an easy acces to leftEdge and rightEdge.</p>
              </li>
            </ul>
            
            <h4>3.1.2.2. Default variables</h4>
            <p>There are only four default variables that have to be declared:</p>
            <ul>
              <li><strong>this.self:</strong> current value of <strong>this</strong>, useful for scope issues.</li>
              <li><strong>this.coreObj:</strong> the instance of CoreObject.js, that will create objects and control the animation.</li>
              <li><strong>this.learnObj:</strong> optional, used to store Learning Mode objects.</li>
              <li><strong>Constants:</strong> values used to create the apropriate pseudocode set.</li>
            </ul>
            
            <h4>3.1.2.3. Initial Items</h4>
            <p>In certain visualisations some initial graphic elements may be necessary. For example, in an Array implementation you'll have to display the array itself.</p>
            <img src="img/array.png" alt="">
            <p>To achieve this you'll have to create all these items in here as this lines of code will execute as this class is instantiated and the graphics will be displayed as soon as the page load.</p>
            
            <h4>3.1.2.4. Default Methods</h4>
            <p>The two important default methods are:</p>
            <ul>
              <li><strong>this.getCore:</strong> this method will return the instance of CoreObject.js to the HTML file.</li>
              <li><strong>this.generatePseudocode:</strong> this method will fill the pseudocode panel when executing a method.</li>
            </ul>
            
            <h4>3.1.2.5. Particular Methods</h4>
            <p>Any method related to this data structure, that will be called from the HTML file.</p>
            
          </section>
          
          <!-- The Two Files -->
          <section id="custom-items">
            <h2>3.2. Custom Items</h2>
            <p>The basic classes provided in this framework are meant to cover all necessary items to implement a data structure visualisation, but there is still room for customisation.</p>
            
            <h3>3.2.1. Custom Shapes</h3>
            <p>Let's say that you want to create an object that is made of two squares, how would you do that? Creating two squares during run time can end up as a big headache, so let's look at the example below:</p>
<pre class="prettyprint linenums">
var DoubleSquareObject = function (coreObj, id, x, y, text1, text2, label, shapeClass, textClass, labelClass) {
  var self = this;
  
  this.coreObj = coreObj;
  
  // ELEMENTS THAT COMPOSE THIS CUSTOM SHAPE
  this.firstSquare = new SquareObject(this.coreObj, id + "-0", x, y, text1, label, shapeClass, textClass, labelClass);
  this.secondSquare = new SquareObject(this.coreObj, id + "-1", x + this.firstSquare.getWidth(), y, text2, null, shapeClass, textClass, labelClass);
  
  // DEFAULT METHODS
  
  this.getAttributes = function () {
    var json = [];
    
    json.push(this.firstSquare.getAttributes());
    json.push(this.secondSquare.getAttributes());
    
    return json;
  }
  
  this.draw = function (dur) {
    this.firstSquare.draw();
    this.secondSquare.draw();
  }
  
  this.getToRemove = function () {
    return this.firstSquare.getToRemove();
  }
  
  this.setToRemove = function (bool) {
    this.firstSquare.setToRemove(bool);
    this.secondSquare.setToRemove(bool);
  }
  
  this.cloneObject = function () {
    var clone = new DoubleSquareObject(this.coreObj);
    clone.cloneFirstSquare(this.firstSquare);
    clone.cloneSecondSquare(this.secondSquare);
    
    return clone;
  }
  
  this.cloneFirstSquare = function (source) {
    this.firstSquare = source.cloneObject();
  }
    
  this.cloneSecondSquare = function (source) {
    this.secondSquare = source.cloneObject();
  }
  
  // PARTICULAR METHODS
  
  this.moveShape = function (x, y) {
    this.firstSquare.moveShape(x, y);
    this.secondSquare.moveShape(x + this.firstSquare.getWidth(), y);
  }
}
</pre>
            <p>In it there are a few things to be noticed:</p>
            <ul>
              <li>Just as we had in regular shapes, we have have a field that we hold the instance of CoreObject that we're using, enabling interactions with other shapes (line 4).</li>
              <li>We'll also have fields to hold the instances of the basic shapes that are composing this (lines 7 and 8).</li>
              <li>TODO</li>
            </ul>
            
            <p>The second step after creating your custom shape is to add it's constructor to <strong>CoreObject.js</strong>:</p>
<pre class="prettyprint linenums">
this.newDoubleSquareObject = function (id, x, y, text1, text2, label, shapeClass, textClass, labelClass) {
  this.objectList[id] = new DoubleSquareObject(this, id, x, y, text1, text2, label, shapeClass, textClass, labelClass);

  return this.objectList[id];
}
</pre>
            <p>With this you'll be able to use and manage your custom shape just as easy as you did with the regular shapes:</p>
<pre class="prettyprint linenums">
var doubleSquare = coreAnim.newDoubleSquareObject("ds", 200, 200, "1", "2", null, null, null, null);
</pre>
            
            <h3>3.2.2. Custom Sets</h3>
            <p>Custom sets can be useful when creating initial shapes. If there's a lot of visualisations that will use an array why not create a custom set just for that? Let's see how the code of a custom set would look:</p>
<pre class="prettyprint linenums">
/**
  * Defines a Pointer object, that contains:
  *   {Number} value
  *   {Object} drawing : an instace of one of the basic shapes (squareObject, nodeObject, etc)
  *   {Object} edge : an instace of the edgeObject
  */
var Node = function () {
  var item,
    pointer,
    drawing,
    edge;
}

/**
  * Defines an Array of Squares with pointers.
  *
  * @param {!CoreAnimObject} coreObj : instance of the CoreAnimObject class.
  * @param {!Number} positions : number of positions of the array.
  */
var ArrayPointer = function (coreObj, positions) {
  var self = this;
  this.coreObj = coreObj;
  
  var mArray = [];
  
  for (var i=0; i&lt;positions; i++){
    mArray[i] = new Node();
    
    mArray[i].item = null; 
    mArray[i].drawing = coreObj.newSquareObject("a" + i, (i+1)*50, 400, null, i, null, null, null);
    mArray[i].edge = coreObj.newEdgeObject("a" + i, mArray[i].drawing.getID(), null, null, EDGE_TYPE.UNIDIRECTIONAL, EDGE_POSITION.TOP, EDGE_POSITION.BOTTOM);
  }
  
  return mArray;
}
</pre>       
            <p>In this example we're creating an array of Squares with pointers, and for this we'll make use of an auxiliar structure (Node, line 7). Than we'll make use of the instance of CoreObject passed as parameter to create all objects that we'll need.</p>
            <p>The main difference between creating a custom shape and a custom set is that in the second case you'll send back all the shapes created for who called this function to manage, so you don't have to worry about creating the methods again.</p>
            <p>Let's see an example of this:</p>
<pre class="prettyprint linenums">
var Hashtable = function () {
  var self = this;
  var coreObj = new CoreObject();
  
  coreObj.newStateList();
  coreObj.saveState();
  
  var mArray;
  
  mArray = new ArrayPointer(coreObj, 15);
  
  coreObj.saveState();
  
  coreObj.play();
}
</pre>
            <p>Which will result in:</p>
            <img src="img/customSet.png" alt="">
            <p>That makes the processes of creating initial shapes smoother and the code clearer.</p>
          </section>
          
          <!-- Learning Mode
          ================================================== -->
          <section id="learning-mode">
            <div class="page-header">
              <h1>4. Learning Mode</h1>
            </div>
            
          </section>
          
          <!-- User Shape and Valid Targets -->
          <section id="valid-target">
            <h2>4.1. User Shape and Valid Targets</h2>
          </section>
          
          <!-- Place Holders -->
          <section id="place-holder">
            <h2>4.2. Place Holders</h2>
          </section>

          <!-- Examples
          ================================================== 
          <section id="examples">
            <div class="page-header">
              <h1>5. Examples</h1>
            </div>
            <p class="lead">Move beyond the base template with a few example layouts. We encourage folks to iterate on these examples and not simply use them as an end result.</p>
            <ul class="thumbnails bootstrap-examples">
              <li class="span3">
                <a class="thumbnail" href="examples/starter-template.html">
                  <img src="assets/img/examples/bootstrap-example-starter.png" alt="">
                </a>
                <h4>Starter template</h4>
                <p>A barebones HTML document with all the Bootstrap CSS and JavaScript included.</p>
              </li>
              <li class="span3">
                <a class="thumbnail" href="examples/hero.html">
                  <img src="assets/img/examples/bootstrap-example-marketing.png" alt="">
                </a>
                <h4>Basic marketing site</h4>
                <p>Featuring a hero unit for a primary message and three supporting elements.</p>
              </li>
              <li class="span3">
                <a class="thumbnail" href="examples/fluid.html">
                  <img src="assets/img/examples/bootstrap-example-fluid.png" alt="">
                </a>
                <h4>Fluid layout</h4>
                <p>Uses our new responsive, fluid grid system to create a seamless liquid layout.</p>
              </li>

              <li class="span3">
                <a class="thumbnail" href="examples/marketing-narrow.html">
                  <img src="assets/img/examples/bootstrap-example-marketing-narrow.png" alt="">
                </a>
                <h4>Narrow marketing</h4>
                <p>Slim, lightweight marketing template for small projects or teams.</p>
              </li>
              <li class="span3">
                <a class="thumbnail" href="examples/justified-nav.html">
                  <img src="assets/img/examples/bootstrap-example-justified-nav.png" alt="">
                </a>
                <h4>Justified nav</h4>
                <p>Marketing page with equal-width navigation links in a modified navbar.</p>
              </li>
              <li class="span3">
                <a class="thumbnail" href="examples/signin.html">
                  <img src="assets/img/examples/bootstrap-example-signin.png" alt="">
                </a>
                <h4>Sign in</h4>
                <p>Barebones sign in form with custom, larger form controls and a flexible layout.</p>
              </li>

              <li class="span3">
                <a class="thumbnail" href="examples/sticky-footer.html">
                  <img src="assets/img/examples/bootstrap-example-sticky-footer.png" alt="">
                </a>
                <h4>Sticky footer</h4>
                <p>Pin a fixed-height footer to the bottom of the user's viewport.</p>
              </li>
              <li class="span3">
                <a class="thumbnail" href="examples/carousel.html">
                  <img src="assets/img/examples/bootstrap-example-carousel.png" alt="">
                </a>
                <h4>Carousel jumbotron</h4>
                <p>A more interactive riff on the basic marketing site featuring a prominent carousel.</p>
              </li>
            </ul>
          </section>
          -->
        </div>
      </div>
    </div>

    <!-- Footer
    ================================================== -->
    <footer class="footer">
    </footer>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
    <script src="../../code/js/jquery-2.1.1.js"></script>
    <script src="js/bootstrap-scrollspy.js"></script>
    <script src="js/bootstrap-transition.js"></script>
    <script src="js/bootstrap-alert.js"></script>
    <script src="js/bootstrap-modal.js"></script>
    <script src="js/bootstrap-dropdown.js"></script>
    <script src="js/bootstrap-tab.js"></script>
    <script src="js/bootstrap-tooltip.js"></script>
    <script src="js/bootstrap-popover.js"></script>
    <script src="js/bootstrap-button.js"></script>
    <script src="js/bootstrap-collapse.js"></script>
    <script src="js/bootstrap-carousel.js"></script>
    <script src="js/bootstrap-typeahead.js"></script>
    <script src="js/bootstrap-affix.js"></script>
    <script src="js/holder.js"></script>
    <script src="js/prettify.js"></script>
    <script src="js/application.js"></script>
  </body>
</html>